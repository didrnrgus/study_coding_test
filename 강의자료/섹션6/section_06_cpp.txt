//////////////////////////////////////////////////////////////////
✅ 1. 올바른 괄호

#include <iostream>
#include <stack>
#include <string>

std::string solution(const std::string& s)
{
    std::stack<char> stack;
    for (char ch : s)
    {
        if (ch == '(') stack.push(ch);
        else {
            if (stack.empty()) return "NO";
            stack.pop();
        }
    }
    return stack.empty() ? "YES" : "NO";
}

int main()
{
    std::string str = "(()(()))())";
    std::cout << solution(str) << std::endl; // 결과: NO
    return 0;
}



#include <iostream>
#include <stack>
#include <string>

std::string solution(const std::string& s)
{
    // (())() 이것은 괄호의 쌍이 올바르게 위치하는 거지만, 
    // (()())) 은 올바른 괄호가 아니다

    std::stack<char> _stack;

    for (int i = 0; i < s.size(); i++)
    {
        if (s[i] == '(')
        {
            _stack.push(s[i]);
        }
        else
        {
            if (_stack.size() == 0) 
                return "NO";

            _stack.pop();
        }
    }

    return _stack.size() > 0 ? "NO" : "YES";
}

int main()
{
    std::string str = "(())()";
    // std::string str = "(()(()))())";
    std::cout << solution(str) << std::endl; // 결과: NO
    return 0;
}


//////////////////////////////////////////////////////////////////
✅ 2. 괄호 문자 제거

#include <iostream>
#include <stack>
#include <string>

// 몽땅 넣어도 괄호 밖에 있는것만 남음.
std::string solution(const std::string& s)
{
    std::stack<char> stack;
    for (char ch : s)
    {
        if (ch == ')') {
            while (!stack.empty() && stack.top() != '(') stack.pop();
            if (!stack.empty()) stack.pop();
        } else {
            stack.push(ch);
        }
    }
    std::string result;
    while (!stack.empty()) {
        result = stack.top() + result;
        stack.pop();
    }
    return result;
}

int main()
{
    std::string str = "(A(BC)D)EF(G(H)(IJ)K)LM(N)";
    std::cout << solution(str) << std::endl; // 결과: EFLM
    return 0;
}



#include <iostream>
#include <stack>
#include <string>

std::string solution(const std::string& s)
{
    // 입력된  문자열에서  소괄호  (  )  사이에  존재하는
    // 모든  문자를  제거하고  남은  문자만  출력하는 프로그램을 작성하세요
    
    // 첫 줄에 문자열이 주어진다.문자열의 길이는 100을 넘지 않는다.
    
    // 마지막께 ( 라면? -> 다음오는문자들은 모두 지워
    // 마지막께 ) 이더라도? 스택의 홀짝이 안맞으면? 다 안닫힌거.

    char last = '\0';
    std::string result;
    std::stack<char> _stack;

    for (int i = 0; i < s.size(); i++)
    {
        if (s[i] == '(')
        {
            _stack.push(s[i]);
            last = s[i];
        }
        else if (s[i] == ')')
        {
            _stack.pop();
            last = s[i];
        }
        else
        {
            if (last == ')' && _stack.size() % 2 == 0)
            {
                result += s[i];
            }
        }
    }

    return result;
}

int main()
{
    std::string str = "(A(BC)D)EF(G(H)(IJ)K)LM(N)";
    std::cout << solution(str) << std::endl; // 결과: EFLM
    return 0;
}



//////////////////////////////////////////////////////////////////
✅ 3. 크레인 인형뽑기
#include <iostream>
#include <vector>
#include <stack>

// 크레인 인형뽑기 로직 함수
int solution(std::vector<std::vector<int>> board, const std::vector<int>& moves)
{
    std::stack<int> stack; // 인형을 담는 바구니 역할
    int answer = 0;        // 터진 인형 개수 합계

    // 각 move 위치(열 번호)를 하나씩 순회
    for (int pos : moves)
    {
        // 위에서 아래로 탐색 (각 행의 해당 열)
        for (std::size_t i = 0; i < board.size(); ++i)
        {
            // 해당 위치에 인형이 존재하면
            if (board[i][pos - 1] != 0)
            {
                int tmp = board[i][pos - 1]; // 뽑은 인형 번호
                board[i][pos - 1] = 0;       // 뽑았으므로 0으로 처리

                // 바구니의 맨 위 인형과 같으면 터뜨림
                if (!stack.empty() && stack.top() == tmp) {
                    stack.pop();       // 같은 인형 제거
                    answer += 2;       // 2개 터짐
                } else {
                    stack.push(tmp);   // 다른 인형이면 바구니에 추가
                }

                break; // 한 번 뽑았으면 그 move는 끝
            }
        }
    }
    return answer; // 총 터진 인형 수 반환
}

int main()
{
    // 인형판 (5x5)
    std::vector<std::vector<int>> board = {
        {0,0,0,0,0},
        {0,0,1,0,3},
        {0,2,5,0,1},
        {4,2,4,4,2},
        {3,5,1,3,1}
    };

    // 크레인이 인형을 뽑을 열 위치 (1-based index)
    std::vector<int> moves = {1,5,3,5,1,2,1,4};

    // 결과 출력: 터진 인형 개수
    std::cout << solution(board, moves) << std::endl; // 결과: 4
    return 0;
}



#include <iostream>
#include <vector>
#include <stack>

int solution(std::vector<std::vector<int>> board, const std::vector<int>& moves)
{
    // 인형이 없는칸은 빈캄 -> 0
    // 터뜨려져 사라진 인형의 갯수

    std::stack<int> basket;
    int removedCount = 0;
    // 내 입맛에 맞게 변환 필요? 아니 그냥

    // moves 순회
    for (int i = 0; i < moves.size(); i++)
    {
        // 내려가는거 순회 -> 숫자 나올떄까지
        for (int j = 0; j < board.size(); j++)
		{
			int sample = board[j][moves[i] - 1];
			if (sample != 0)
			{
				board[j][moves[i] - 1] = 0;

				if (!basket.empty() && basket.top() == sample)
				{
					basket.pop();
					removedCount += 2;
				}
				else
				{
					basket.push(sample);
				}
				break;
			}
		}
	}

    return removedCount;
}

int main()
{
    std::vector<std::vector<int>> board = {
        {0,0,0,0,0},
        {0,0,1,0,3},
        {0,2,5,0,1},
        {4,2,4,4,2},
        {3,5,1,3,1}
    };
    std::vector<int> moves = { 1,5,3,5,1,2,1,4 };
    std::cout << solution(board, moves) << std::endl; // 결과: 4
    return 0;
}




//////////////////////////////////////////////////////////////////
✅ 4. 후위식 연산

#include <iostream>
#include <stack>
#include <string>
#include <cctype>

int solution(const std::string& s)
{
    std::stack<int> stack;
    for (char ch : s)
    {
        if (std::isdigit(ch)) stack.push(ch - '0');
        else {
            int rt = stack.top(); stack.pop();
            int lt = stack.top(); stack.pop();
            if (ch == '+') stack.push(lt + rt);
            else if (ch == '-') stack.push(lt - rt);
            else if (ch == '*') stack.push(lt * rt);
            else if (ch == '/') stack.push(lt / rt);
        }
    }
    return stack.top();
}

int main()
{
    std::string str = "352+*9-";
    std::cout << solution(str) << std::endl; // 결과: 12
    return 0;
}





//////////////////////////////////////////////////////////////////
✅ 5. 쇠막대기

#include <iostream>
#include <stack>
#include <string>

int solution(const std::string& s)
{
    std::stack<char> stack;
    int answer = 0;
    for (std::size_t i = 0; i < s.size(); ++i)
    {
        if (s[i] == '(') {
            stack.push('(');
        } else {
            stack.pop();
            if (s[i - 1] == '(') {
                answer += stack.size();
            } else {
                answer++;
            }
        }
    }
    return answer;
}

int main()
{
    std::string str = "()(((()())(())()))(())";
    std::cout << solution(str) << std::endl; // 결과: 17
    return 0;
}





//////////////////////////////////////////////////////////////////
✅ 6. 공주 구하기

#include <iostream>
#include <queue>

int solution(int n, int k)
{
    std::queue<int> q;
    for (int i = 1; i <= n; ++i)
        q.push(i);

    while (q.size() > 1)
    {
        for (int i = 1; i < k; ++i)
        {
            q.push(q.front());
            q.pop();
        }
        q.pop();
    }
    return q.front();
}

int main()
{
    int n = 8;
    int k = 3;
    std::cout << solution(n, k) << std::endl; // 결과: 7
    return 0;
}





//////////////////////////////////////////////////////////////////
✅ 7. 교육 과정 설계

#include <iostream>
#include <queue>
#include <string>

std::string solution(const std::string& need, const std::string& plan)
{
    std::queue<char> q;
    for (char ch : need) q.push(ch);

    for (char ch : plan)
    {
        if (q.empty()) break;
        if (ch == q.front()) {
            q.pop();
        } else if (need.find(ch) != std::string::npos) {
            return "NO";
        }
    }
    return q.empty() ? "YES" : "NO";
}

int main()
{
    std::string need = "CBA";
    std::string plan = "CBDAGE";
    std::cout << solution(need, plan) << std::endl; // 결과: YES
    return 0;
}