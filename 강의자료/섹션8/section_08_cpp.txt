///////////////////////////////////////////////////////////
✅ 1. 재귀함수

#include <iostream>

void DFS(int L)
{
    if (L == 0) return;
    else
    {
        DFS(L - 1);
        std::cout << L << std::endl;
    }
}

void solution(int n)
{
    DFS(n);
}

int main()
{
    solution(3);
    return 0;
}





///////////////////////////////////////////////////////////
✅ 2. 이진수 출력 (재귀)

#include <iostream>
#include <string>

// 디버깅 필기를 한다면 오른쪽부터 써진다. -> 맨마지막 1자리부터터
void DFS(int n, std::string& answer)
{
    if (n == 0) return;
    else
    {
        DFS(n / 2, answer);
        answer += std::to_string(n % 2);
    }
}

std::string solution(int n)
{
    std::string answer;
    DFS(n, answer);
    return answer;
}

int main()
{
    std::cout << solution(11) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 3. 이진트리 순회

#include <iostream>
#include <string>

void DFS(int v, std::string& answer)
{
    if (v > 7) return;
    else
    {
        answer += std::to_string(v) + " ";
        DFS(v * 2, answer);
        DFS(v * 2 + 1, answer);
    }
}

std::string solution(int n)
{
    std::string answer;
    DFS(n, answer);
    return answer;
}

int main()
{
    std::cout << solution(1) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 4. 부분집합 구하기

#include <iostream>
#include <vector>
#include <string>

// DFS를 이용해 부분집합을 생성하는 함수
void DFS(int L, int n, std::vector<int>& ch, std::vector<std::string>& answer)
{
    if (L == n + 1)  // 종료 조건: L이 n을 넘으면 현재까지 선택된 부분집합을 문자열로 만들어 저장
    {
        std::string tmp;
        for (int i = 1; i <= n; ++i)
        {
            if (ch[i] == 1) // ch[i]가 1이면 해당 원소를 부분집합에 포함시킴
                tmp += std::to_string(i) + " ";
        }
        if (!tmp.empty()) // 공집합이 아니면 결과 벡터에 추가
            answer.push_back(tmp);
    }
    else
    {
        // 원소를 포함시키는 경우
        ch[L] = 1;
        DFS(L + 1, n, ch, answer);

        // 원소를 포함시키지 않는 경우
        ch[L] = 0;
        DFS(L + 1, n, ch, answer);
    }
}

// 부분집합을 구하는 solution 함수
std::vector<std::string> solution(int n)
{
    std::vector<std::string> answer;         // 결과 부분집합들을 담을 벡터
    std::vector<int> ch(n + 1, 0);           // 각 원소가 부분집합에 포함되었는지를 나타내는 체크 배열
    DFS(1, n, ch, answer);                   // DFS 탐색 시작
    return answer;
}

// 실행 테스트용 main 함수
int main()
{
    std::vector<std::string> result = solution(3);  // 1~3의 부분집합 구하기
    for (const auto& s : result)                    // 결과 출력
        std::cout << s << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 5. 합이 같은 부분집합
/*
    // 두 부분집합의 합이 같은 경우
    if (total - sum == sum)
    // 부분집합 구함 -> 합 -> 나머지 포함안되애들 ->합
    // total -> 합 == 포함안된애들 합
    // 굳이 여러번 부분집합 구해서 중복 안구해도
    // 한번에 될 수 있는 방법임.
*/
#include <iostream>
#include <vector>
#include <numeric> // std::accumulate
#include <string>

bool flag = false;               // 정답을 찾았는지 여부를 저장하는 플래그
std::string answer = "NO";       // 결과 문자열 (기본값: "NO")

// DFS: 현재 인덱스 L, 현재까지의 부분합 sum, 전체합 total, 입력 배열 arr
void DFS(int L, int sum, int total, const std::vector<int>& arr)
{
    if (flag) return; // 정답이 이미 "YES"이면 더 이상 탐색하지 않음 (백트래킹)

    // 종료 조건: 모든 원소를 한 번씩 포함/제외 처리한 경우
    if (L == static_cast<int>(arr.size()))
    {
        // 두 부분집합의 합이 같은 경우
        if (total - sum == sum)
        {
            answer = "YES"; // 정답 갱신
            flag = true;    // 더 이상 탐색하지 않도록 플래그 설정
        }
    }
    else
    {
        // 현재 원소를 포함한 경우
        DFS(L + 1, sum + arr[L], total, arr);

        // 현재 원소를 포함하지 않은 경우
        DFS(L + 1, sum, total, arr);
    }
}

// 메인 로직 함수: 부분집합 합 비교
std::string solution(const std::vector<int>& arr)
{
    int total = std::accumulate(arr.begin(), arr.end(), 0); // 전체 합 계산
    DFS(0, 0, total, arr); // DFS 시작
    return answer; // 결과 반환
}

int main()
{
    std::vector<int> arr = { 1, 3, 5, 6, 7, 10 }; // 입력 배열
    std::cout << solution(arr) << std::endl;     // 결과 출력 ("YES" 또는 "NO")
    return 0;
}

//////////////////////////////////////////////////

#include <iostream>
#include <vector>
#include <unordered_map>
#include <numeric>

bool flag = false;
std::string answer = "NO";
std::unordered_map<int, bool> subsetSums; // 부분집합 합을 저장할 맵

void DFS(int L, int n, int sum, const std::vector<int>& arr)
{
    if (flag) return;

    if (L == n)
    {
        if (sum == 0) return; // 공집합은 제외
        if (subsetSums.find(sum) != subsetSums.end())
        {
            answer = "YES";
            flag = true;
        }
        else
        {
            subsetSums[sum] = true; // 새로운 합 저장
        }
    }
    else
    {
        // 현재 원소 포함
        DFS(L + 1, n, sum + arr[L], arr);

        // 현재 원소 제외
        DFS(L + 1, n, sum, arr);
    }
}

std::string solution(const std::vector<int>& arr)
{
    subsetSums.clear();
    flag = false;
    answer = "NO";
    DFS(0, arr.size(), 0, arr);
    return answer;
}

int main()
{
    std::vector<int> arr = {1, 3, 5, 6, 7, 10};
    std::cout << solution(arr) << std::endl; // 결과: YES
    return 0;
}



///////////////////////////////////////////////////////////
✅ 6. 바둑이 승차

#include <iostream>
#include <vector>
#include <algorithm> // std::max 사용

// 전역 변수 선언
int answer = std::numeric_limits<int>::min(); // 현재까지 찾은 최대 무게 저장
int capacity = 0;                             // 제한 무게 (최대 허용치)

// DFS 함수: 가능한 모든 조합을 탐색해 최대 무게를 찾음
// L : 현재 몇 번째 짐을 고려 중인지 (레벨)
// sum : 지금까지 태운 짐들의 총 무게
// arr : 짐들의 무게 리스트
void DFS(int L, int sum, const std::vector<int>& arr)
{
    // 현재 누적 무게가 허용치를 넘으면 탐색 종료 (가지치기)
    if (sum > capacity) return;

    // 모든 짐을 다 고려했으면 최대값 갱신
    if (L == static_cast<int>(arr.size()))
    {
        answer = std::max(answer, sum);
    }
    else
    {
        // 현재 짐을 태우는 경우
        DFS(L + 1, sum + arr[L], arr);

        // 현재 짐을 태우지 않는 경우
        DFS(L + 1, sum, arr);
    }
}

// solution 함수: 문제의 진입점 역할
int solution(int c, const std::vector<int>& arr)
{
    answer = std::numeric_limits<int>::min(); // 매 호출 시 초기화
    capacity = c;                             // 전역 제한 무게 설정
    DFS(0, 0, arr);                           // DFS 탐색 시작
    return answer;                            // 최종 결과 반환
}

// 테스트용 main 함수
int main()
{
    std::vector<int> arr = { 81, 58, 42, 33, 61 }; // 각 짐의 무게 리스트
    std::cout << solution(259, arr) << std::endl; // 최대 실을 수 있는 무게 출력
    return 0;
}






///////////////////////////////////////////////////////////
✅ 7. 최대점수 구하기

#include <iostream>
#include <vector>
#include <algorithm>

int answer = std::numeric_limits<int>::min();

void DFS(int L, int sum, int time, int m, const std::vector<int>& ps, const std::vector<int>& pt)
{
    if (time > m) return;
    if (L == static_cast<int>(ps.size()))
    {
        answer = std::max(answer, sum);
    }
    else
    {
        DFS(L + 1, sum + ps[L], time + pt[L], m, ps, pt);
        DFS(L + 1, sum, time, m, ps, pt);
    }
}

int solution(int m, const std::vector<int>& ps, const std::vector<int>& pt)
{
    DFS(0, 0, 0, m, ps, pt);
    return answer;
}

int main()
{
    std::vector<int> ps = {10, 25, 15, 6, 7};
    std::vector<int> pt = {5, 12, 8, 3, 4};
    std::cout << solution(20, ps, pt) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 8. 중복순열

#include <iostream>
#include <vector>

void DFS(int L, int n, int m, std::vector<int>& tmp, std::vector<std::vector<int>>& answer)
{
    if (L == m)
    {
        answer.push_back(tmp);
    }
    else
    {
        for (int i = 1; i <= n; ++i)
        {
            tmp[L] = i;
            DFS(L + 1, n, m, tmp, answer);
        }
    }
}

std::vector<std::vector<int>> solution(int n, int m)
{
    std::vector<std::vector<int>> answer;
    std::vector<int> tmp(m);
    DFS(0, n, m, tmp, answer);
    return answer;
}

int main()
{
    std::vector<std::vector<int>> result = solution(3, 2);
    for (const auto& vec : result)
    {
        for (int x : vec)
            std::cout << x << ' ';
        std::cout << std::endl;
    }
    return 0;
}





///////////////////////////////////////////////////////////
✅ 9. 동전교환

#include <iostream>
#include <vector>
#include <algorithm>

int answer = std::numeric_limits<int>::max();

void DFS(int L, int sum, int m, const std::vector<int>& coins)
{
    if (sum > m) return;
    if (L >= answer) return;
    if (sum == m)
    {
        answer = std::min(answer, L);
    }
    else
    {
        for (std::size_t i = 0; i < coins.size(); ++i)
        {
            DFS(L + 1, sum + coins[i], m, coins);
        }
    }
}

int solution(int m, const std::vector<int>& coins)
{
    DFS(0, 0, m, coins);
    return answer;
}

int main()
{
    std::vector<int> coins = {1, 2, 5};
    std::cout << solution(15, coins) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 10. 순열 구하기

#include <iostream>
#include <vector>

void DFS(int L, int m, const std::vector<int>& arr, std::vector<int>& ch,
         std::vector<int>& tmp, std::vector<std::vector<int>>& answer)
{
    if (L == m)
    {
        answer.push_back(tmp);
    }
    else
    {
        for (std::size_t i = 0; i < arr.size(); ++i)
        {
            if (ch[i] == 0)
            {
                ch[i] = 1;
                tmp[L] = arr[i];
                DFS(L + 1, m, arr, ch, tmp, answer);
                ch[i] = 0;
            }
        }
    }
}

std::vector<std::vector<int>> solution(int m, const std::vector<int>& arr)
{
    std::vector<std::vector<int>> answer;
    std::vector<int> ch(arr.size(), 0);
    std::vector<int> tmp(m);
    DFS(0, m, arr, ch, tmp, answer);
    return answer;
}

int main()
{
    std::vector<int> arr = {3, 6, 9};
    std::vector<std::vector<int>> result = solution(2, arr);
    for (const auto& vec : result)
    {
        for (int x : vec)
            std::cout << x << ' ';
        std::cout << std::endl;
    }
    return 0;
}





///////////////////////////////////////////////////////////
✅ 11. 팩토리얼

#include <iostream>

int DFS(int n)
{
    if (n == 1) return 1;
    else return n * DFS(n - 1);
}

int solution(int n)
{
    return DFS(n);
}

int main()
{
    std::cout << solution(5) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 12. 조합수 (메모이제이션)

#include <iostream>
#include <vector>

int dy[35][35] = {0};

int DFS(int n, int r)
{
    if (dy[n][r] > 0) return dy[n][r];
    if (n == r || r == 0) return 1;
    return dy[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r);
}

int solution(int n, int r)
{
    return DFS(n, r);
}

int main()
{
    std::cout << solution(5, 3) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 13. 수열 추측하기

#include <iostream>
#include <vector>

int dy[11][11] = {0};
int ch[11] = {0};
int p[11], b[11];
int n, f;
bool flag = false;
std::vector<int> answer;

int combi(int n, int r)
{
    if (dy[n][r] > 0) return dy[n][r];
    if (n == r || r == 0) return 1;
    return dy[n][r] = combi(n - 1, r - 1) + combi(n - 1, r);
}

void DFS(int L, int sum)
{
    if (flag) return;
    if (L == n && sum == f)
    {
        flag = true;
        for (int i = 0; i < n; ++i) answer.push_back(p[i]);
    }
    else
    {
        for (int i = 1; i <= n; ++i)
        {
            if (ch[i] == 0)
            {
                ch[i] = 1;
                p[L] = i;
                DFS(L + 1, sum + (b[L] * p[L]));
                ch[i] = 0;
            }
        }
    }
}

std::vector<int> solution(int _n, int _f)
{
    n = _n;
    f = _f;
    for (int i = 0; i < n; ++i)
        b[i] = combi(n - 1, i);
    DFS(0, 0);
    return answer;
}

int main()
{
    std::vector<int> res = solution(4, 16);
    for (int x : res) std::cout << x << " ";
    std::cout << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 14. 조합 구하기

#include <iostream>
#include <vector>

void DFS(int L, int s, int n, int m, std::vector<int>& tmp, std::vector<std::vector<int>>& answer)
{
    if (L == m)
    {
        answer.push_back(tmp);
    }
    else
    {
        for (int i = s; i <= n; ++i)
        {
            tmp[L] = i;
            DFS(L + 1, i + 1, n, m, tmp, answer);
        }
    }
}

std::vector<std::vector<int>> solution(int n, int m)
{
    std::vector<std::vector<int>> answer;
    std::vector<int> tmp(m);
    DFS(0, 1, n, m, tmp, answer);
    return answer;
}

int main()
{
    std::vector<std::vector<int>> result = solution(4, 2);
    for (const auto& vec : result)
    {
        for (int x : vec)
            std::cout << x << ' ';
        std::cout << std::endl;
    }
    return 0;
}





///////////////////////////////////////////////////////////
✅ 15. 수들의 조합

#include <iostream>
#include <vector>

int answer = 0;

void DFS(int L, int s, int sum, int k, int m, const std::vector<int>& arr)
{
    if (L == k)
    {
        if (sum % m == 0) ++answer;
    }
    else
    {
        for (int i = s; i < static_cast<int>(arr.size()); ++i)
        {
            DFS(L + 1, i + 1, sum + arr[i], k, m, arr);
        }
    }
}

int solution(int n, int k, const std::vector<int>& arr, int m)
{
    answer = 0;
    DFS(0, 0, 0, k, m, arr);
    return answer;
}

int main()
{
    std::vector<int> arr = {2, 4, 5, 8, 12};
    std::cout << solution(5, 3, arr, 6) << std::endl;
    return 0;
}