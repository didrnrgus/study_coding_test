///////////////////////////////////////////////////////////
✅ 1. 재귀함수

#include <iostream>

void DFS(int L)
{
    if (L == 0) return;
    else
    {
        DFS(L - 1);
        std::cout << L << std::endl;
    }
}

void solution(int n)
{
    DFS(n);
}

int main()
{
    solution(3);
    return 0;
}





///////////////////////////////////////////////////////////
✅ 2. 이진수 출력 (재귀)

#include <iostream>
#include <string>

void DFS(int n, std::string& answer)
{
    if (n == 0) return;
    else
    {
        DFS(n / 2, answer);
        answer += std::to_string(n % 2);
    }
}

std::string solution(int n)
{
    std::string answer;
    DFS(n, answer);
    return answer;
}

int main()
{
    std::cout << solution(11) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 3. 이진트리 순회

#include <iostream>
#include <string>

void DFS(int v, std::string& answer)
{
    if (v > 7) return;
    else
    {
        answer += std::to_string(v) + " ";
        DFS(v * 2, answer);
        DFS(v * 2 + 1, answer);
    }
}

std::string solution(int n)
{
    std::string answer;
    DFS(n, answer);
    return answer;
}

int main()
{
    std::cout << solution(1) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 4. 부분집합 구하기

#include <iostream>
#include <vector>
#include <string>

void DFS(int L, int n, std::vector<int>& ch, std::vector<std::string>& answer)
{
    if (L == n + 1)
    {
        std::string tmp;
        for (int i = 1; i <= n; ++i)
        {
            if (ch[i] == 1) tmp += std::to_string(i) + " ";
        }
        if (!tmp.empty()) answer.push_back(tmp);
    }
    else
    {
        ch[L] = 1;
        DFS(L + 1, n, ch, answer);
        ch[L] = 0;
        DFS(L + 1, n, ch, answer);
    }
}

std::vector<std::string> solution(int n)
{
    std::vector<std::string> answer;
    std::vector<int> ch(n + 1, 0);
    DFS(1, n, ch, answer);
    return answer;
}

int main()
{
    std::vector<std::string> result = solution(3);
    for (const auto& s : result)
        std::cout << s << std::endl;
    return 0;
}
계속해서 5번부터 10번까지 변환해드릴게요.

이어서 나머지 파일들도 C++로 변환한 코드를 아래에 각각 제공합니다.






///////////////////////////////////////////////////////////
✅ 5. 합이 같은 부분집합

#include <iostream>
#include <vector>
#include <numeric>
#include <string>

bool flag = false;
std::string answer = "NO";

void DFS(int L, int sum, int total, const std::vector<int>& arr)
{
    if (flag) return;
    if (L == static_cast<int>(arr.size()))
    {
        if (total - sum == sum)
        {
            answer = "YES";
            flag = true;
        }
    }
    else
    {
        DFS(L + 1, sum + arr[L], total, arr);
        DFS(L + 1, sum, total, arr);
    }
}

std::string solution(const std::vector<int>& arr)
{
    int total = std::accumulate(arr.begin(), arr.end(), 0);
    DFS(0, 0, total, arr);
    return answer;
}

int main()
{
    std::vector<int> arr = {1, 3, 5, 6, 7, 10};
    std::cout << solution(arr) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 6. 바둑이 승차

#include <iostream>
#include <vector>
#include <algorithm>

int answer = std::numeric_limits<int>::min();

void DFS(int L, int sum, int c, const std::vector<int>& arr)
{
    if (sum > c) return;
    if (L == static_cast<int>(arr.size()))
    {
        answer = std::max(answer, sum);
    }
    else
    {
        DFS(L + 1, sum + arr[L], c, arr);
        DFS(L + 1, sum, c, arr);
    }
}

int solution(int c, const std::vector<int>& arr)
{
    DFS(0, 0, c, arr);
    return answer;
}

int main()
{
    std::vector<int> arr = {81, 58, 42, 33, 61};
    std::cout << solution(259, arr) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 7. 최대점수 구하기

#include <iostream>
#include <vector>
#include <algorithm>

int answer = std::numeric_limits<int>::min();

void DFS(int L, int sum, int time, int m, const std::vector<int>& ps, const std::vector<int>& pt)
{
    if (time > m) return;
    if (L == static_cast<int>(ps.size()))
    {
        answer = std::max(answer, sum);
    }
    else
    {
        DFS(L + 1, sum + ps[L], time + pt[L], m, ps, pt);
        DFS(L + 1, sum, time, m, ps, pt);
    }
}

int solution(int m, const std::vector<int>& ps, const std::vector<int>& pt)
{
    DFS(0, 0, 0, m, ps, pt);
    return answer;
}

int main()
{
    std::vector<int> ps = {10, 25, 15, 6, 7};
    std::vector<int> pt = {5, 12, 8, 3, 4};
    std::cout << solution(20, ps, pt) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 8. 중복순열

#include <iostream>
#include <vector>

void DFS(int L, int n, int m, std::vector<int>& tmp, std::vector<std::vector<int>>& answer)
{
    if (L == m)
    {
        answer.push_back(tmp);
    }
    else
    {
        for (int i = 1; i <= n; ++i)
        {
            tmp[L] = i;
            DFS(L + 1, n, m, tmp, answer);
        }
    }
}

std::vector<std::vector<int>> solution(int n, int m)
{
    std::vector<std::vector<int>> answer;
    std::vector<int> tmp(m);
    DFS(0, n, m, tmp, answer);
    return answer;
}

int main()
{
    std::vector<std::vector<int>> result = solution(3, 2);
    for (const auto& vec : result)
    {
        for (int x : vec)
            std::cout << x << ' ';
        std::cout << std::endl;
    }
    return 0;
}





///////////////////////////////////////////////////////////
✅ 9. 동전교환

#include <iostream>
#include <vector>
#include <algorithm>

int answer = std::numeric_limits<int>::max();

void DFS(int L, int sum, int m, const std::vector<int>& coins)
{
    if (sum > m) return;
    if (L >= answer) return;
    if (sum == m)
    {
        answer = std::min(answer, L);
    }
    else
    {
        for (std::size_t i = 0; i < coins.size(); ++i)
        {
            DFS(L + 1, sum + coins[i], m, coins);
        }
    }
}

int solution(int m, const std::vector<int>& coins)
{
    DFS(0, 0, m, coins);
    return answer;
}

int main()
{
    std::vector<int> coins = {1, 2, 5};
    std::cout << solution(15, coins) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 10. 순열 구하기

#include <iostream>
#include <vector>

void DFS(int L, int m, const std::vector<int>& arr, std::vector<int>& ch,
         std::vector<int>& tmp, std::vector<std::vector<int>>& answer)
{
    if (L == m)
    {
        answer.push_back(tmp);
    }
    else
    {
        for (std::size_t i = 0; i < arr.size(); ++i)
        {
            if (ch[i] == 0)
            {
                ch[i] = 1;
                tmp[L] = arr[i];
                DFS(L + 1, m, arr, ch, tmp, answer);
                ch[i] = 0;
            }
        }
    }
}

std::vector<std::vector<int>> solution(int m, const std::vector<int>& arr)
{
    std::vector<std::vector<int>> answer;
    std::vector<int> ch(arr.size(), 0);
    std::vector<int> tmp(m);
    DFS(0, m, arr, ch, tmp, answer);
    return answer;
}

int main()
{
    std::vector<int> arr = {3, 6, 9};
    std::vector<std::vector<int>> result = solution(2, arr);
    for (const auto& vec : result)
    {
        for (int x : vec)
            std::cout << x << ' ';
        std::cout << std::endl;
    }
    return 0;
}





///////////////////////////////////////////////////////////
✅ 11. 팩토리얼

#include <iostream>

int DFS(int n)
{
    if (n == 1) return 1;
    else return n * DFS(n - 1);
}

int solution(int n)
{
    return DFS(n);
}

int main()
{
    std::cout << solution(5) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 12. 조합수 (메모이제이션)

#include <iostream>
#include <vector>

int dy[35][35] = {0};

int DFS(int n, int r)
{
    if (dy[n][r] > 0) return dy[n][r];
    if (n == r || r == 0) return 1;
    return dy[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r);
}

int solution(int n, int r)
{
    return DFS(n, r);
}

int main()
{
    std::cout << solution(5, 3) << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 13. 수열 추측하기

#include <iostream>
#include <vector>

int dy[11][11] = {0};
int ch[11] = {0};
int p[11], b[11];
int n, f;
bool flag = false;
std::vector<int> answer;

int combi(int n, int r)
{
    if (dy[n][r] > 0) return dy[n][r];
    if (n == r || r == 0) return 1;
    return dy[n][r] = combi(n - 1, r - 1) + combi(n - 1, r);
}

void DFS(int L, int sum)
{
    if (flag) return;
    if (L == n && sum == f)
    {
        flag = true;
        for (int i = 0; i < n; ++i) answer.push_back(p[i]);
    }
    else
    {
        for (int i = 1; i <= n; ++i)
        {
            if (ch[i] == 0)
            {
                ch[i] = 1;
                p[L] = i;
                DFS(L + 1, sum + (b[L] * p[L]));
                ch[i] = 0;
            }
        }
    }
}

std::vector<int> solution(int _n, int _f)
{
    n = _n;
    f = _f;
    for (int i = 0; i < n; ++i)
        b[i] = combi(n - 1, i);
    DFS(0, 0);
    return answer;
}

int main()
{
    std::vector<int> res = solution(4, 16);
    for (int x : res) std::cout << x << " ";
    std::cout << std::endl;
    return 0;
}





///////////////////////////////////////////////////////////
✅ 14. 조합 구하기

#include <iostream>
#include <vector>

void DFS(int L, int s, int n, int m, std::vector<int>& tmp, std::vector<std::vector<int>>& answer)
{
    if (L == m)
    {
        answer.push_back(tmp);
    }
    else
    {
        for (int i = s; i <= n; ++i)
        {
            tmp[L] = i;
            DFS(L + 1, i + 1, n, m, tmp, answer);
        }
    }
}

std::vector<std::vector<int>> solution(int n, int m)
{
    std::vector<std::vector<int>> answer;
    std::vector<int> tmp(m);
    DFS(0, 1, n, m, tmp, answer);
    return answer;
}

int main()
{
    std::vector<std::vector<int>> result = solution(4, 2);
    for (const auto& vec : result)
    {
        for (int x : vec)
            std::cout << x << ' ';
        std::cout << std::endl;
    }
    return 0;
}





///////////////////////////////////////////////////////////
✅ 15. 수들의 조합

#include <iostream>
#include <vector>

int answer = 0;

void DFS(int L, int s, int sum, int k, int m, const std::vector<int>& arr)
{
    if (L == k)
    {
        if (sum % m == 0) ++answer;
    }
    else
    {
        for (int i = s; i < static_cast<int>(arr.size()); ++i)
        {
            DFS(L + 1, i + 1, sum + arr[i], k, m, arr);
        }
    }
}

int solution(int n, int k, const std::vector<int>& arr, int m)
{
    answer = 0;
    DFS(0, 0, 0, k, m, arr);
    return answer;
}

int main()
{
    std::vector<int> arr = {2, 4, 5, 8, 12};
    std::cout << solution(5, 3, arr, 6) << std::endl;
    return 0;
}